<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Amos&#39;s blog</title>
		<link>https://example.com/posts/</link>
		<description>Recent content in Posts on Amos&#39;s blog</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Mon, 01 Aug 2022 09:17:28 +0800</lastBuildDate>
		<atom:link href="https://example.com/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Git操作练习</title>
			<link>https://example.com/posts/git%E6%93%8D%E4%BD%9C%E7%BB%83%E4%B9%A0/</link>
			<pubDate>Mon, 01 Aug 2022 09:17:28 +0800</pubDate>
			
			<guid>https://example.com/posts/git%E6%93%8D%E4%BD%9C%E7%BB%83%E4%B9%A0/</guid>
			<description>一、本地仓库 本地第一次提交
git init 初始化本地仓库 git add . 添加本地所有文件到暂存区 git add [文件名称] 添加单个文件到暂存区 git commit -m &amp;lsquo;备注&amp;rsquo; 提交文件到本地HEAD区 git remote -v （可选）查看远程仓库信息 git remote add origin git@github.com:IsAmos01/GW-GQiang.git 与GitHub仓库进行关联 git remote rm origin (可选)删除远程仓库，即解绑 git push -u origin master 将本地内容推送到远程仓库（第一次） git push origin master 将本地内容推送到远程仓库（之后） 本地第二次提交
git add [文件名称] 添加文件 git commit -m &amp;lsquo;备注信息&amp;rsquo; git push origin master 将本地新增内容推送到远程仓库 二、多人协作 三、其他操作 git status 查看当前文件状态,以及哪些文件修改了（相比暂存前后的文件） git diff 详细查看哪些文件修改了，修改了什么地方 git rm [文件名称] 丛暂存区域移除文件，并连带从工作目录中删除指定的文件。 git log 查看提交记录 git chekout 切换分支 </description>
			<content type="html"><![CDATA[<h3 id="一本地仓库">一、本地仓库</h3>
<p>本地第一次提交</p>
<ol>
<li>git init 初始化本地仓库</li>
<li>git add . 添加本地所有文件到暂存区
git add [文件名称] 添加单个文件到暂存区</li>
<li>git commit -m &lsquo;备注&rsquo;  提交文件到本地HEAD区</li>
<li>git remote -v  （可选）查看远程仓库信息</li>
<li>git remote add origin  <a href="mailto:git@github.com">git@github.com</a>:IsAmos01/GW-GQiang.git 与GitHub仓库进行关联</li>
<li>git remote rm origin (可选)删除远程仓库，即解绑</li>
<li>git push -u origin master  将本地内容推送到远程仓库（第一次）
git push origin master 将本地内容推送到远程仓库（之后）</li>
</ol>
<p>本地第二次提交</p>
<ol>
<li>git add [文件名称]  添加文件</li>
<li>git commit -m &lsquo;备注信息&rsquo;</li>
<li>git push origin master  将本地新增内容推送到远程仓库</li>
</ol>
<h2 id="二多人协作">二、多人协作</h2>
<h2 id="三其他操作">三、其他操作</h2>
<ul>
<li>git status  查看当前文件状态,以及哪些文件修改了（相比暂存前后的文件）</li>
<li>git diff 详细查看哪些文件修改了，修改了什么地方</li>
<li>git rm [文件名称]  丛暂存区域移除文件，并连带从工作目录中删除指定的文件。</li>
<li>git log 查看提交记录</li>
<li>git chekout  切换分支</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>八月目标</title>
			<link>https://example.com/posts/%E5%85%AB%E6%9C%88%E7%9B%AE%E6%A0%87/</link>
			<pubDate>Sat, 30 Jul 2022 16:09:06 +0800</pubDate>
			
			<guid>https://example.com/posts/%E5%85%AB%E6%9C%88%E7%9B%AE%E6%A0%87/</guid>
			<description>问题总结： 键盘打字太慢 git操作不够熟练 Linux系统操作需要熟练 mybatis源码需要掌握 Java需要从0-1进行掌握 服务架构需要仔细掌握 数据库的掌握 八月计划： 第一周： ​	总目标：数据库学习、Linux系统的下载安装及操作、Java基础、面向对象
具体实施：
周一：git基础操作练习，Java基础； 周二：Java基础语法、IO、异常处理、面向对象等，MySQL语法（增删改查、多表查询等）； 周三：Java（集合框架、网络编程、多线程等）、MySQL函数及回顾 周四：实践练习 周五：实践练习 第二周： ​	总目标：mybatis源码分析、Java数据结构基础以及实战练习
第三周： ​	总目标：服务架构的了解、mybatis源码分析
第四周： ​	总目标：实操</description>
			<content type="html"><![CDATA[<h2 id="问题总结">问题总结：</h2>
<ol>
<li>键盘打字太慢</li>
<li>git操作不够熟练</li>
<li>Linux系统操作需要熟练</li>
<li>mybatis源码需要掌握</li>
<li>Java需要从0-1进行掌握</li>
<li>服务架构需要仔细掌握</li>
<li>数据库的掌握</li>
</ol>
<h2 id="八月计划">八月计划：</h2>
<h3 id="第一周">第一周：</h3>
<p>​		总目标：数据库学习、Linux系统的下载安装及操作、Java基础、面向对象</p>
<p>具体实施：</p>
<ul>
<li>周一：git基础操作练习，Java基础；</li>
<li>周二：Java基础语法、IO、异常处理、面向对象等，MySQL语法（增删改查、多表查询等）；</li>
<li>周三：Java（集合框架、网络编程、多线程等）、MySQL函数及回顾</li>
<li>周四：实践练习</li>
<li>周五：实践练习</li>
</ul>
<h3 id="第二周">第二周：</h3>
<p>​		总目标：mybatis源码分析、Java数据结构基础以及实战练习</p>
<h3 id="第三周">第三周：</h3>
<p>​		总目标：服务架构的了解、mybatis源码分析</p>
<h3 id="第四周">第四周：</h3>
<p>​		总目标：实操</p>
]]></content>
		</item>
		
		<item>
			<title>线程池</title>
			<link>https://example.com/posts/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</link>
			<pubDate>Sat, 30 Jul 2022 16:08:25 +0800</pubDate>
			
			<guid>https://example.com/posts/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</guid>
			<description>一、线程池默认工作流程 线程在有任务的时候会创建核心的线程数corePoolSize
当线程满了（有任务但是线程被使用完）不会立即扩容,而是放到阻塞队列中,当阻塞队列满了之后才会继续创建线程。
如果队列满了,线程数达到最大线程数则会执行拒绝策略。
当线程数大于核心线程数事,超过KeepAliveTime(闲置时间),线程会被回收,最终会保持corePoolSize个线程。
二、五种实现 1、newSingleThreadExecutor()
​	池里只有一条线程,如果线程因为异常而停止，会自动新建一个线程补充
2、newFixedThreadPool()
​	创建一个核心线程数跟最大线程数相同的线程池,线程池数量大小不变,如果有任务放入队列,等待空闲线程。
3、newCachedThreadPool()
​	线程池是创建一个核心线程数为0，最大线程为Inter.MAX_VALUE的线程池，线程池数量不确定,有空闲线程则优先使用,没用则创建新的线程处理任务,处理完放入线程池。
4、newScheduledThreadPool()
​	创建一个没有最大线程数限制的可以定时执行线程池,还有创建一个只有单个线程的可以定时执行线程池（Executors.newSingleThreadScheduledExecutor()）
三、七个核心参数 1、七个参数
corePoolSize: 线程池核心线程个数
workQueue:用于保存等待执行任务的阻塞队列
maximunPoolSize: 线程池最大线程数量
ThreadFactory: 创建线程的工厂
RejectedExecutionHandler: 队列满，并且线程达到最大线程数量的时候，对新任务的处理策略
keeyAliveTime: 空闲线程存活时间
TimeUnit: 存活时间单位
2、CPU密集型
​	获得cpu的核数，不同的硬件不一样，设置核数的线程数量可以通过Runtime.getRuntime().availableProcessors()；
3、IO密集型
​	IO非常消耗资源，所有我们需要计算大型的IO程序任务有多少个。一般来说，线程池最大值 &amp;gt;大型任务的数量即可，一般设置大型任务的数量*2。
4、线程池大小= 最大线程数 + 阻塞队列大小
5、LinkedBlockingQueue给put(放入元素),take(取元素)都声明了一把锁，放入和取互不影响，效率更高。
6、ArrayBlockingQueue 使用数组实现，在声明的时候必须指定长度，如果长度太大，造成内存浪费，长度太小，并发性能不高，如果数组满了，就无法放入元素，除非有其他线程取出元素，放入和取出都使用同一把锁，因此存在竞争，效率比LinkedBlockingQueue低。
四、四种策略 AbortPolicy（被拒绝了抛出异常）
CallerRunsPolicy(使用调用者所在线程执行，就是哪里来的回哪里去)
DiscardOldestPolicy(尝试去竞争第一个，失败了也不抛异常)
DiscardPolicy(默默丢弃、不抛异常)
五、拒绝策略执行则么办？ 另外创建一个队列,当拒绝策略执行将任务放入队列。
如果 是特别重要的话就 放入DB去持久化,给任务加个状态,通过状态来判断任务的执行情况。
其他情况要根据场景考虑 比如又些任务过期淘汰</description>
			<content type="html"><![CDATA[<h2 id="一线程池默认工作流程">一、线程池默认工作流程</h2>
<ul>
<li>
<p>线程在有任务的时候会创建核心的线程数corePoolSize</p>
</li>
<li>
<p>当线程满了（有任务但是线程被使用完）不会立即扩容,而是放到阻塞队列中,当阻塞队列满了之后才会继续创建线程。</p>
</li>
<li>
<p>如果队列满了,线程数达到最大线程数则会执行拒绝策略。</p>
</li>
<li>
<p>当线程数大于核心线程数事,超过KeepAliveTime(闲置时间),线程会被回收,最终会保持corePoolSize个线程。</p>
</li>
</ul>
<h2 id="二五种实现">二、五种实现</h2>
<p>1、newSingleThreadExecutor()</p>
<p>​	池里只有一条线程,如果线程因为异常而停止，会自动新建一个线程补充</p>
<p>2、newFixedThreadPool()</p>
<p>​	创建一个核心线程数跟最大线程数相同的线程池,线程池数量大小不变,如果有任务放入队列,等待空闲线程。</p>
<p>3、newCachedThreadPool()</p>
<p>​	线程池是创建一个核心线程数为0，最大线程为Inter.MAX_VALUE的线程池，线程池数量不确定,有空闲线程则优先使用,没用则创建新的线程处理任务,处理完放入线程池。</p>
<p>4、newScheduledThreadPool()</p>
<p>​	创建一个没有最大线程数限制的可以定时执行线程池,还有创建一个只有单个线程的可以定时执行线程池（Executors.newSingleThreadScheduledExecutor()）</p>
<h2 id="三七个核心参数">三、七个核心参数</h2>
<p>1、七个参数</p>
<ul>
<li>
<p>corePoolSize: 线程池核心线程个数</p>
</li>
<li>
<p>workQueue:用于保存等待执行任务的阻塞队列</p>
</li>
<li>
<p>maximunPoolSize: 线程池最大线程数量</p>
</li>
<li>
<p>ThreadFactory: 创建线程的工厂</p>
</li>
<li>
<p>RejectedExecutionHandler: 队列满，并且线程达到最大线程数量的时候，对新任务的处理策略</p>
</li>
<li>
<p>keeyAliveTime: 空闲线程存活时间</p>
</li>
<li>
<p>TimeUnit: 存活时间单位</p>
</li>
</ul>
<p>2、CPU密集型</p>
<p>​	获得cpu的核数，不同的硬件不一样，设置核数的线程数量可以通过Runtime.getRuntime().availableProcessors()；</p>
<p>3、IO密集型</p>
<p>​	IO非常消耗资源，所有我们需要计算大型的IO程序任务有多少个。一般来说，线程池最大值 &gt;大型任务的数量即可，一般设置大型任务的数量*2。</p>
<p>4、线程池大小= 最大线程数 + 阻塞队列大小</p>
<p>5、LinkedBlockingQueue给put(放入元素),take(取元素)都声明了一把锁，放入和取互不影响，效率更高。</p>
<p>6、ArrayBlockingQueue 使用数组实现，在声明的时候必须指定长度，如果长度太大，造成内存浪费，长度太小，并发性能不高，如果数组满了，就无法放入元素，除非有其他线程取出元素，放入和取出都使用同一把锁，因此存在竞争，效率比LinkedBlockingQueue低。</p>
<h2 id="四四种策略">四、四种策略</h2>
<ul>
<li>
<p>AbortPolicy（被拒绝了抛出异常）</p>
</li>
<li>
<p>CallerRunsPolicy(使用调用者所在线程执行，就是哪里来的回哪里去)</p>
</li>
<li>
<p>DiscardOldestPolicy(尝试去竞争第一个，失败了也不抛异常)</p>
</li>
<li>
<p>DiscardPolicy(默默丢弃、不抛异常)</p>
</li>
</ul>
<h2 id="五拒绝策略执行则么办">五、拒绝策略执行则么办？</h2>
<ul>
<li>
<p>另外创建一个队列,当拒绝策略执行将任务放入队列。</p>
</li>
<li>
<p>如果 是特别重要的话就 放入DB去持久化,给任务加个状态,通过状态来判断任务的执行情况。</p>
</li>
<li>
<p>其他情况要根据场景考虑 比如又些任务过期淘汰</p>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>ThreadLocal</title>
			<link>https://example.com/posts/threadlocal/</link>
			<pubDate>Sat, 30 Jul 2022 16:07:36 +0800</pubDate>
			
			<guid>https://example.com/posts/threadlocal/</guid>
			<description>ThreadLocal 一、WHAT ​	ThreadLocal类用来提供线程内部的局部变量，不同的线程之间不会干扰；这种变量在多线程环境下访问时能保证各个线程的变量相互独立于其他线程内的变量；在线程的生命周期内起作用，可以减少同一个线程内多个函数或组件之间的一些公共变量传递的复杂性。
1.threaLocal和synchronized的区别 synchronized： 1.以时间换空间的方式，只提供一份变量让不同线程访问 2.多个线程之间访问资源的同步 ThreadLocal： 1.以空间换时间的方式，为每个变量提供一份变量副本 2.多线程中让每个线程之间的相互隔离 2.ThreadLocal的内部结构 Thread维护了一个ThreadLocalMap，其中key值为ThreadLocal，value值为实际变量副本值
二、WHY ​	1.每个线程需要有自己单独的实例 ​	2.实力需要在多个方法中共享，但不希望被多线程共享
三、HOW get():获取当前线程绑定的变量
首先获取当前线程，根据当前线程获取一个Map 如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的Entry e，否则转到4； 如果e不为null，则返回e.value，否则转到4 Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为key和value创建一个新的Map set():将变量绑定到当前线程中
首先获取当前线程，并根据当前线程获取一个Map 如果获取的Map不为空，则将参数设置到Map中（当前ThreadLocal的引用作为key） 如果Map为空，则给该线程创建Map，并设置初始值 remove():移除当前线程绑定的局部变量，该方法可以帮助JVM进行GC
initialValue():返回当前线程局部变量的初始值</description>
			<content type="html"><![CDATA[<h1 id="threadlocal">ThreadLocal</h1>
<h2 id="一what">一、WHAT</h2>
<p>​	ThreadLocal类用来提供线程内部的局部变量，不同的线程之间不会干扰；这种变量在多线程环境下访问时能保证各个线程的变量相互独立于其他线程内的变量；在线程的生命周期内起作用，可以减少同一个线程内多个函数或组件之间的一些公共变量传递的复杂性。</p>
<p>1.threaLocal和synchronized的区别
synchronized：
1.以时间换空间的方式，只提供一份变量让不同线程访问
2.多个线程之间访问资源的同步
ThreadLocal：
1.以空间换时间的方式，为每个变量提供一份变量副本
2.多线程中让每个线程之间的相互隔离
2.ThreadLocal的内部结构
Thread维护了一个ThreadLocalMap，其中key值为ThreadLocal，value值为实际变量副本值</p>
<h2 id="二why">二、WHY</h2>
<p>​	1.每个线程需要有自己单独的实例
​	2.实力需要在多个方法中共享，但不希望被多线程共享</p>
<h2 id="三how">三、HOW</h2>
<p>get():获取当前线程绑定的变量</p>
<ul>
<li>首先获取当前线程，根据当前线程获取一个Map</li>
<li>如果获取的Map不为空，则在Map中以ThreadLocal的引用作为key来在Map中获取对应的Entry e，否则转到4；</li>
<li>如果e不为null，则返回e.value，否则转到4</li>
<li>Map为空或者e为空，则通过initialValue函数获取初始值value，然后用ThreadLocal的引用和value作为key和value创建一个新的Map</li>
</ul>
<p>set():将变量绑定到当前线程中</p>
<ul>
<li>首先获取当前线程，并根据当前线程获取一个Map</li>
<li>如果获取的Map不为空，则将参数设置到Map中（当前ThreadLocal的引用作为key）</li>
<li>如果Map为空，则给该线程创建Map，并设置初始值</li>
</ul>
<p>remove():移除当前线程绑定的局部变量，该方法可以帮助JVM进行GC</p>
<p>initialValue():返回当前线程局部变量的初始值</p>
]]></content>
		</item>
		
		<item>
			<title>HashMap</title>
			<link>https://example.com/posts/hashmap/</link>
			<pubDate>Sat, 30 Jul 2022 16:06:47 +0800</pubDate>
			
			<guid>https://example.com/posts/hashmap/</guid>
			<description>HashMap的结构及工作原理
一、WHAT ​	HashMap是基于哈希表的Map接口的非同步实现，此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
​	在Java中数组和链表是典型的数据存储结构。
1.数组
​	数组的存储区间连续，有点是随机访问性强，查找速度快，缺点是插入和删除速度快，内存利用率高且大小不固定，比较灵活，缺点是不能随机查找，查找速度慢。
2.链表
​	链表区间离散，优点是插入删除速度快，内存利用率高，大小不固定，比较灵活，缺点是不能随即查找，查找速度慢。
3.HashMap
​	哈希表也叫散列表，是一种神奇的结构，最大的特点就是快。在Java1.7之前是数组+链表，之后是数组+链表+红黑树。如果链表
4.HashMap的节点
​	HashMap是一个集合，键值对的集合，源码中每个节点用&amp;lt;K、V&amp;gt;表示。
​	final int hash;
​	final K key;
​	V value;
​	Node&amp;lt;K,V&amp;gt; next;
​	Node是一个内部类，智利的key为键，value为值，next指向下一个元素，可以看出HashMap中的元素不是一个简单的键值对，还包含下一个元素的引用。
二、WHY ​	在HashMap底层使用数组+链表+红黑树的结构完美的解决了数组和链表的问题，是的查询、插入、删除的效率都很高。
​	在jdk1.8中，如果链表长度大于8且节点数组长度大于64时，则会将链表转为红黑树。
三、HOW 1.put()方法
将K、V封装到Node对象当中； 利用hashcode()方法得出k的hash值； 通过哈希函数将hash值转换为数组的下标； 如果下标没有任何元素，就把Node添加到这个位置，如果下标对应位置上有链表，就将k与链表上的每个节点进行equal，如果返回是false，那这个新的节点会被添加到末尾，吐过有一个返回true，则这个节点的value将会被覆盖。 2.get()方法
先调用hashCode算法得出k的哈希值，并通过哈希算法转换为数组的下标； 通过数组下标快速定位到某个位置上，如果位置上什么都没有，就返回null； 如果这个位置上有单向链表，那么就将k与单向链表上的每个节点的k进行equal，吐过返回false，就返回null；如果返回true，则返回该节点value值。 </description>
			<content type="html"><![CDATA[<p>HashMap的结构及工作原理</p>
<h2 id="一what">一、WHAT</h2>
<p>​	HashMap是基于哈希表的Map接口的非同步实现，此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>​	在Java中数组和链表是典型的数据存储结构。</p>
<p>1.数组</p>
<p>​	数组的存储区间连续，有点是随机访问性强，查找速度快，缺点是插入和删除速度快，内存利用率高且大小不固定，比较灵活，缺点是不能随机查找，查找速度慢。</p>
<p>2.链表</p>
<p>​	链表区间离散，优点是插入删除速度快，内存利用率高，大小不固定，比较灵活，缺点是不能随即查找，查找速度慢。</p>
<p>3.HashMap</p>
<p>​	哈希表也叫散列表，是一种神奇的结构，最大的特点就是快。在Java1.7之前是数组+链表，之后是数组+链表+红黑树。如果链表</p>
<p>4.HashMap的节点</p>
<p>​	HashMap是一个集合，键值对的集合，源码中每个节点用&lt;K、V&gt;表示。</p>
<p>​	final int hash;</p>
<p>​	final K key;</p>
<p>​	V value;</p>
<p>​	Node&lt;K,V&gt; next;</p>
<p>​	Node是一个内部类，智利的key为键，value为值，next指向下一个元素，可以看出HashMap中的元素不是一个简单的键值对，还包含下一个元素的引用。</p>
<h2 id="二why">二、WHY</h2>
<p>​	在HashMap底层使用数组+链表+红黑树的结构完美的解决了数组和链表的问题，是的查询、插入、删除的效率都很高。</p>
<p>​	在jdk1.8中，如果链表长度大于8且节点数组长度大于64时，则会将链表转为红黑树。</p>
<h2 id="三how">三、HOW</h2>
<p>1.put()方法</p>
<ul>
<li>将K、V封装到Node对象当中；</li>
<li>利用hashcode()方法得出k的hash值；</li>
<li>通过哈希函数将hash值转换为数组的下标；</li>
<li>如果下标没有任何元素，就把Node添加到这个位置，如果下标对应位置上有链表，就将k与链表上的每个节点进行equal，如果返回是false，那这个新的节点会被添加到末尾，吐过有一个返回true，则这个节点的value将会被覆盖。</li>
</ul>
<p>2.get()方法</p>
<ul>
<li>先调用hashCode算法得出k的哈希值，并通过哈希算法转换为数组的下标；</li>
<li>通过数组下标快速定位到某个位置上，如果位置上什么都没有，就返回null；</li>
<li>如果这个位置上有单向链表，那么就将k与单向链表上的每个节点的k进行equal，吐过返回false，就返回null；如果返回true，则返回该节点value值。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>First_post</title>
			<link>https://example.com/posts/first_post/</link>
			<pubDate>Sat, 30 Jul 2022 15:02:18 +0800</pubDate>
			
			<guid>https://example.com/posts/first_post/</guid>
			<description>hello world</description>
			<content type="html"><![CDATA[<p>hello world</p>
]]></content>
		</item>
		
		<item>
			<title></title>
			<link>https://example.com/posts/sql%E8%AF%AD%E8%A8%80/</link>
			<pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
			
			<guid>https://example.com/posts/sql%E8%AF%AD%E8%A8%80/</guid>
			<description>SQL语言 一、SQL基础 1.SELECT SELECT column_name,column_name FROM table_name;
SELECT * FROM table_name;
SELECT DISTINCT column_name,column_name FROM table_name; 返回列中不同的值
2.WHERE SELECT column_name,column_name FROM table_name WHERE column_name operator value;
WHERE用于提取那些满足条件的记录；
3.AND&amp;amp;OR 4.ORDER BY 5.INSERTE INTO INSERT INTO table_name VALUES (value1,value2,value3,&amp;hellip;); INSERT INTO table_name (column1,column2,column3,&amp;hellip;) VALUES (value1,value2,value3,&amp;hellip;); 6.UPDATA UPDATE table_name SET column1=value1,column2=value2,&amp;hellip; WHERE some_column=some_value; 7.DELETE DELETE FROM table_name WHERE some_column=some_value; 8.CREATE DATABASE 9.CREATE TABLE 1O.SQL约束 NOT NULL UNIQUE PRIMARY KEY FOREIGN KEY CHECK DEFAULT 设置默认值 11.</description>
			<content type="html"><![CDATA[<h1 id="sql语言">SQL语言</h1>
<h2 id="一sql基础">一、SQL基础</h2>
<h3 id="1select">1.SELECT</h3>
<ul>
<li>
<p><strong>SELECT</strong> column_name,column_name FROM table_name;</p>
<p><strong>SELECT</strong> * FROM table_name;</p>
</li>
<li>
<p><strong>SELECT</strong> <strong>DISTINCT</strong> column_name,column_name FROM table_name; 返回列中不同的值</p>
</li>
</ul>
<h3 id="2where">2.WHERE</h3>
<ul>
<li>
<p>SELECT column_name,column_name FROM table_name <strong>WHERE</strong> column_name operator value;</p>
<p>WHERE用于提取那些满足条件的记录；</p>
</li>
</ul>
<h3 id="3andor">3.AND&amp;OR</h3>
<h3 id="4order-by">4.ORDER BY</h3>
<h3 id="5inserte-into">5.INSERTE INTO</h3>
<ul>
<li><strong>INSERT INTO</strong> table_name <strong>VALUES</strong> (value1,value2,value3,&hellip;);</li>
<li><strong>INSERT INTO</strong> table_name (column1,column2,column3,&hellip;)
<strong>VALUES</strong> (value1,value2,value3,&hellip;);</li>
</ul>
<h3 id="6updata">6.UPDATA</h3>
<ul>
<li><strong>UPDATE</strong> table_name <strong>SET</strong> column1=value1,column2=value2,&hellip; <strong>WHERE</strong> some_column=some_value;</li>
</ul>
<h3 id="7delete">7.DELETE</h3>
<ul>
<li><strong>DELETE</strong> FROM table_name <strong>WHERE</strong> some_column=some_value;</li>
</ul>
<h3 id="8create---database">8.CREATE   DATABASE</h3>
<h3 id="9create---table">9.CREATE   TABLE</h3>
<h3 id="1osql约束">1O.SQL约束</h3>
<ul>
<li>NOT NULL</li>
<li>UNIQUE</li>
<li>PRIMARY KEY</li>
<li>FOREIGN KEY</li>
<li>CHECK</li>
<li>DEFAULT  设置默认值</li>
</ul>
<h3 id="11创建索引">11.创建索引</h3>
<ul>
<li>
<p><strong>CREATE （UNIQUE) INDEX</strong> index_name <strong>ON</strong> table_name (column_name)</p>
<p>在表上创建一个简单的索引,UNIQUE代表是否允许重复的值</p>
</li>
</ul>
<h3 id="12drop">12.DROP</h3>
<ul>
<li>DROP INDEX  删除索引</li>
<li>DROP TABLE  删除表</li>
<li>DROP DATABASE  删除数据库</li>
<li>TRUNCATE TABLE 删除表中的数据</li>
</ul>
<h3 id="13alter-table">13.ALTER TABLE</h3>
<p>ALTER TABLE 语句用于在已有的表中添加、删除或修改列。</p>
<ul>
<li><strong>ALTER TABLE</strong> table_name <strong>ADD</strong> column_name datatype</li>
<li><strong>ALTER TABLE</strong> table_name <strong>DROP</strong> COLUMN column_name</li>
<li><strong>ALTER TABLE</strong> table_name <strong>MODIFY</strong> COLUMN column_name datatype</li>
</ul>
<h2 id="二sql进阶">二、SQL进阶</h2>
<h3 id="1like">1.LIKE</h3>
<h3 id="2通配符">2.通配符</h3>
<h3 id="3别名">3.别名</h3>
<ul>
<li>SELECT column_name <strong>AS</strong> alias_name FROM table_name;</li>
</ul>
<h3 id="4between">4.BETWEEN</h3>
<ul>
<li>SELECT column_name(s) FROM table_name WHERE column_name <strong>BETWEEN</strong> value1 <strong>AND</strong> value2;</li>
</ul>
<h3 id="5连接">5.连接</h3>
<h3 id="6内连接">6.内连接</h3>
<ul>
<li>
<p>SELECT column_name(s) FROM table1 <strong>INNER JOIN</strong> table2 <strong>ON</strong> table1.column_name=table2.column_name;</p>
<p>内连接中表的顺序不影响，<strong>INNER</strong>也可以去掉</p>
</li>
</ul>
<h3 id="7左连接做外连接">7.左连接（做外连接）</h3>
<ul>
<li>
<p>SELECT column_name(s) FROM table1 <strong>LEFT (OUTER) JOIN</strong> table2 <strong>ON</strong> table1.column_name=table2.column_name;</p>
<p>OUT可以去掉</p>
</li>
</ul>
<h3 id="8右连接右外连接">8.右连接（右外连接）</h3>
<ul>
<li>SELECT column_name(s) FROM table1 <strong>RIGHT (OUTER) JOIN</strong> table2 <strong>ON</strong> table1.column_name=table2.column_name;</li>
</ul>
<h3 id="9全外连接mysql不支持">9.全外连接（MySQL不支持）</h3>
<ul>
<li>SELECT column_name(s) FROM table1 <strong>FULL OUTER JOIN</strong> table2 ON table1.column_name=table2.column_name;</li>
</ul>
<h3 id="10union">10.UNION</h3>
<p><strong>UNION</strong> 操作符合并两个或多个 SELECT 语句的结果。</p>
<ul>
<li>
<p>SELECT column_name(s) FROM table1</p>
<p><strong>UNION</strong></p>
<p>SELECT column_name(s) FROM table2;</p>
</li>
</ul>
<p><strong>UNION</strong>操作符选取不同的值，如果允许重复的值，请使用<strong>UNION ALL</strong></p>
<ul>
<li>
<p>SELECT column_name(s) FROM table1</p>
<p><strong>UNION ALL</strong></p>
<p>SELECT column_name(s) FROM table2;</p>
<p>UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</p>
</li>
</ul>
<p>**注意:**UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</p>
<h3 id="11select--into">11.SELECT  INTO</h3>
<ul>
<li>
<p>MySQL 数据库不支持 SELECT &hellip; INTO 语句，但支持 <strong>INSERT INTO &hellip; SELECT</strong> 。</p>
</li>
<li>
<p>CREATE TABLE 新表</p>
<p>AS</p>
<p>SELECT * FROM 旧表</p>
</li>
</ul>
<h3 id="12insert-into-select">12.INSERT INTO SELECT</h3>
<ul>
<li>
<p><strong>INSERT INTO</strong> table2</p>
<p>SELECT * FROM table1;</p>
</li>
<li>
<p><strong>INSERT INTO</strong> table2 (column_name(s))</p>
<p>SELECT column_name(s) FROM table1;</p>
</li>
</ul>
<h2 id="三sql函数">三、SQL函数</h2>
<p>1.GROUP BY</p>
<p>对一个（或多个）列的结果进行分组</p>
<p>SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value <strong>GROUP BY</strong> column_name;</p>
]]></content>
		</item>
		
	</channel>
</rss>
